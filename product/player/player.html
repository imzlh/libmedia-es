<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="origin-trial" content="AvVVD0vRFcVG5+Z0vn8wrVPWUt98Q6/e73ZIicw+Noko1IwIrkB1siQlxc+IdvM0nISlKulUqzx2QflMi1YgFA8AAABieyJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjkwMDAiLCJmZWF0dXJlIjoiV2ViQXNzZW1ibHlKU1Byb21pc2VJbnRlZ3JhdGlvbiIsImV4cGlyeSI6MTczOTkyMzE5OX0=">
    <title>在线本地播放器</title>
    <meta name="description" content="Online Local Player">
    <meta name="description" content="在线的本地播放器，支持多种视频格式，多种编码格式">
    <style>
      html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
      }
      #app {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      #background-video {
        object-fit: cover;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
      }
      .avplayer-ui-container {
        --libmedia-ui-background-color: rgba(0, 0, 0, 0.3);
      }
      .avplayer-ui-container .avplayer-ui-folder-container {
        background-color: rgba(0, 0, 0, 0.2) !important;
      }
      .avplayer-ui-container .avplayer-ui-folder-container .avplayer-ui-folder {
        backdrop-filter: blur(10px);
        background-color: rgba(0, 0, 0, 0.1) !important;
      }
      .avplayer-ui-container .avplayer-ui-folder-container .avplayer-ui-folder-toggle {
        backdrop-filter: blur(10px);
        background-color: rgba(0, 0, 0, 0.1) !important;
      }
    </style>
</head>
<body>
  <video id="background-video" loop muted poster="./background.png"></video>
  <div id="app"></div>
  <script>
    window.CHEAP_DISABLE_THREAD = false
  </script>
  <script src="./sw.js"></script>
  <script src="../../dist/cheap-polyfill.js"></script>
  <script src="../../dist/avplayer-ui/avplayer.js"></script>

  <script defer type="module">

    let supportAtomic = false
    let supportSimd = false

    const backgroundVideo = document.querySelector('#background-video')

    let webgpu = false;

    // 测试WebGPU是否可用
    try{
        const clearColor = { r: 0.0, g: 0.5, b: 1.0, a: 1.0 },
            vertices = new Float32Array([
                0.0,  0.6, 0, 1, 1, 0, 0, 1,
                -0.5, -0.6, 0, 1, 0, 1, 0, 1,
                0.5, -0.6, 0, 1, 0, 0, 1, 1
            ]),shaders = `
struct VertexOut {
  @builtin(position) position : vec4f,
  @location(0) color : vec4f
}

@vertex
fn vertex(@location(0) position: vec4f,
               @location(1) color: vec4f) -> VertexOut
{
  var output : VertexOut;
  output.position = position;
  output.color = color;
  return output;
}

@fragment
fn fragment(fragData: VertexOut) -> @location(0) vec4f
{
  return fragData.color;
}
    `;
        const adapter = await navigator.gpu.requestAdapter(),
            device = await adapter.requestDevice(),
            shaderModule = device.createShaderModule({ code: shaders });

        const canvas = document.createElement('canvas'),
            context = canvas.getContext('webgpu');

        context.configure({
            device,
            format: navigator.gpu.getPreferredCanvasFormat(),
            alphaMode: 'premultiplied'
        });

        const vertexBuffer = device.createBuffer({
            size: vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(vertexBuffer, 0, vertices, 0, vertices.length);

        const vertexBuffers = [{
                attributes: [{
                    shaderLocation: 0, // position
                    offset: 0,
                    format: 'float32x4'
                }, {
                    shaderLocation: 1, // color
                    offset: 16,
                    format: 'float32x4'
                }],
                arrayStride: 32,
                stepMode: 'vertex'
            }],pipelineDescriptor = {
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vertex_main',
                    buffers: vertexBuffers
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fragment',
                    targets: [{
                        format: navigator.gpu.getPreferredCanvasFormat()
                    }]
                },
                primitive: {
                    topology: 'triangle-list'
                },
                layout: 'auto'
            };

        const renderPipeline = device.createRenderPipeline(pipelineDescriptor),
            commandEncoder = device.createCommandEncoder(),
            renderPassDescriptor = {
                colorAttachments: [{
                clearValue: clearColor,
                loadOp: 'clear',
                storeOp: 'store',
                view: context.getCurrentTexture().createView()
                }]
            },
            passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

        passEncoder.setPipeline(renderPipeline);
        passEncoder.setVertexBuffer(0, vertexBuffer);
        passEncoder.draw(3);
        passEncoder.end();
        device.queue.submit([commandEncoder.finish()]);

        webgpu = true;
    }catch(e){
        console.warn('Your device doesnot support WebGPU.');
        console.debug(e);
    }

    const player = new AVPlayer({
      container: document.querySelector('#app'),
      getWasm: (type, codecId) => {
        switch (type) {
          case 'decoder': {

            if (codecId >= 65536 && codecId <= 65572) {
              return `../../dist/decode/pcm${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
            }

            switch (codecId) {
              // H264
              case 27:
                return `../../dist/decode/h264${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // theora
              case 30:
                return `../../dist/decode/theora${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // AAC
              case 86018:
                return `../../dist/decode/aac${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // ac3
              case 86019:
                return `../../dist/decode/ac3${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // eac3
              case 86056:
                return `../../dist/decode/eac3${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // dts
              case 86020:
                return `../../dist/decode/dca${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
                // MP3
              case 86017:
                return `../../dist/decode/mp3${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // HEVC
              case 173:
                return `../../dist/decode/hevc${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // VVC
              case 196:
                return `../../dist/decode/vvc${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // Mpeg4
              case 12:
                return `../../dist/decode/mpeg4${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // AV1
              case 225:
                return `../../dist/decode/av1${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // Speex
              case 86051:
                return `../../dist/decode/speex${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // Opus
              case 86076:
                return `../../dist/decode/opus${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // flac
              case 86028:
                return `../../dist/decode/flac${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // vorbis
              case 86021:
                return `../../dist/decode/vorbis${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // vp8
              case 139:
                return `../../dist/decode/vp8${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              // vp9
              case 167:
                return `../../dist/decode/vp9${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
              default:
                return null
            }
            break
          }
          case 'resampler':
            return `../../dist/resample/resample${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
          case 'stretchpitcher':
            return `../../dist/stretchpitch/stretchpitch${supportSimd ? '-simd' : (supportAtomic ? '-atomic' : '')}.wasm`
        }
      },
      enableHardware: true,
      jitterBufferMax: 4,
      jitterBufferMin: 1,
      lowLatency: true,
      indicatorUrl: '../../src/ui/avplayer/img/indicator.svg',
      pauseStateUrl: '../../src/ui/avplayer/img/state.svg',
      errorStateUrl: '../../src/ui/avplayer/img/error.svg',
      "enableWebGPU": webgpu,
      fullscreenDom: document.body
    })

    if (typeof VideoDecoder === 'function') {
      const support = VideoDecoder.isConfigSupported({
        codec: 'avc1.640034',
        codedWidth: 3840,
        codedHeight: 2160,
        hardwareAcceleration: 'prefer-hardware'
      }).then((support) => {
        if (support.supported) {
          if (screen.availWidth * screen.availHeight <= 2560 * 1440) {
            backgroundVideo.src = './background_2k_30fps.mp4'
          }
          else {
            backgroundVideo.src = './background_4k_30fps.mp4'
          }

          backgroundVideo.play()

          player.on('played', () => {
            if (player.hasVideo()) {
              if (!backgroundVideo.paused) {
                backgroundVideo.pause()
              }
            }
            else if (backgroundVideo.paused) {
              backgroundVideo.play()
            }
          })
          player.on('stopped', () => {
            if (backgroundVideo.paused) {
              backgroundVideo.play()
            }
          })
          let playBeforeHidden = false
          document.addEventListener('visibilitychange', (event) => {
            if (document.visibilityState === 'hidden') {
              playBeforeHidden = !backgroundVideo.paused
              if (!backgroundVideo.paused) {
                backgroundVideo.pause()
              }
            }
            else {
              if (playBeforeHidden) {
                backgroundVideo.play()
              }
            }
          })
        }
      })
    }

    if (typeof crossOriginIsolated === 'boolean' && !crossOriginIsolated) {
      navigator.serviceWorker.ready.then(function(reg) {
        if (!crossOriginIsolated && !navigator.serviceWorker.controller) {
          window.location.reload()
        }
      })
    }

    function testSupportWasmAtomic() {
      const asm = 'AGFzbQEAAAABBgFgAX8BfwISAQNlbnYGbWVtb3J5AgMBgIACAwIBAAcJAQVsb2FkOAAACgoBCAAgAP4SAAAL'
      const binaryData = atob(asm)
      const uint8Array = new Uint8Array(binaryData.length)
      for (let i = 0; i < binaryData.length; i++) {
        uint8Array[i] = binaryData.charCodeAt(i)
      }

      const instance = WebAssembly.compile(uint8Array).then(() => {
        console.log('wasm atomic support')
        supportAtomic = true
      }, () => {
        supportAtomic = false
        console.log('wasm atomic not support')
      })
    }

    function testSupportWasmSimd() {
      const asm = 'AGFzbQEAAAABBQFgAAF7AhIBA2VudgZtZW1vcnkCAwGAgAIDAgEACgoBCABBAP0ABAAL'
      const binaryData = atob(asm)
      const uint8Array = new Uint8Array(binaryData.length)
      for (let i = 0; i < binaryData.length; i++) {
        uint8Array[i] = binaryData.charCodeAt(i)
      }

      const instance = WebAssembly.compile(uint8Array).then(() => {
        console.log('wasm simd support')
        supportSimd = true
      }, () => {
        supportSimd = false
        console.log('wasm simd not support')
      })
    }

    testSupportWasmAtomic()
    testSupportWasmSimd()

    AVPlayer.setLogLevel(1)
  </script>
</body>
</html>